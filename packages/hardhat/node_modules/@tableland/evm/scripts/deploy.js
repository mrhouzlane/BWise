"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const hardhat_1 = require("hardhat");
const assert_1 = __importDefault(require("assert"));
const sleep = (0, util_1.promisify)(setTimeout);
const pollTimeout = 60 * 10 * 1000; // 10 min timeout (required for Filecoin)
const pollInterval = 5000;
async function main() {
    var _a, _b, _c;
    console.log(`\nDeploying new proxy to '${hardhat_1.network.name}'...`);
    // Get proxy owner account
    const [account] = await hardhat_1.ethers.getSigners();
    if (account.provider === undefined) {
        throw Error("missing provider");
    }
    // Get base URI
    if (hardhat_1.baseURI === undefined || hardhat_1.baseURI === "") {
        throw Error(`missing baseURIs entry for '${hardhat_1.network.name}'`);
    }
    console.log(`Using base URI '${hardhat_1.baseURI}'`);
    // Don't allow multiple proxies per network
    if (hardhat_1.proxy !== undefined && hardhat_1.proxy !== "") {
        throw Error(`proxy already deployed to '${hardhat_1.network.name}'`);
    }
    // Deploy proxy
    const Factory = await hardhat_1.ethers.getContractFactory("TablelandTables");
    const tables = await (await hardhat_1.upgrades.deployProxy(Factory, [hardhat_1.baseURI], {
        kind: "uups",
        timeout: pollTimeout,
        pollingInterval: pollInterval,
    })).deployed();
    console.log("New proxy address:", tables.address);
    // Check implementation
    // Note: We poll here because the impl won't be visible from the proxy until the next tipset on Filecoin.
    // Note: See https://docs.filecoin.io/smart-contracts/developing-contracts/best-practices/#consistently-generating-transaction-receipts.
    const startTime = Date.now();
    while (!(await checkImpl(tables.address))) {
        const elapsedTime = Date.now() - startTime;
        if (elapsedTime >= pollTimeout) {
            throw Error("impl did not become visible from proxy");
        }
        console.log("Waiting for implementation to be visible from proxy...");
        await sleep(pollInterval);
    }
    // Create health bot table
    const { chainId } = await account.provider.getNetwork();
    const createStatement = `create table healthbot_${chainId} (counter integer);`;
    let tx = await tables["create(address,string)"](account.address, createStatement);
    let receipt = await tx.wait();
    const [, createEvent] = (_a = receipt.events) !== null && _a !== void 0 ? _a : [];
    const tableId = createEvent.args.tableId;
    console.log("Healthbot table created as:", `healthbot_${chainId}_${tableId}`);
    // Insert first row into health bot table
    const runStatement = `insert into healthbot_${chainId}_${tableId} values (1);`;
    tx = await tables["mutate(address,uint256,string)"](account.address, tableId, runStatement);
    receipt = await tx.wait();
    const [runEvent] = (_b = receipt.events) !== null && _b !== void 0 ? _b : [];
    (0, assert_1.default)(runEvent.args.statement === runStatement, "insert statement mismatch");
    console.log("Healthbot table updated with:", (_c = runEvent.args) === null || _c === void 0 ? void 0 : _c.statement);
    // Warn that proxy address needs to be saved in config
    console.log(`\nSave 'proxies.${hardhat_1.network.name}: "${tables.address}"' in 'network.ts'!`);
}
async function checkImpl(proxy) {
    try {
        const impl = await hardhat_1.upgrades.erc1967.getImplementationAddress(proxy);
        console.log("New implementation address:", impl);
        return true;
    }
    catch (error) {
        return false;
    }
}
main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});
//# sourceMappingURL=deploy.js.map