"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const hardhat_1 = require("hardhat");
const assert_1 = __importDefault(require("assert"));
const sleep = (0, util_1.promisify)(setTimeout);
const pollTimeout = 60 * 10 * 1000; // 10 min timeout (required for Filecoin)
const pollInterval = 5000;
async function main() {
    console.log(`\nUpgrading '${hardhat_1.network.name}' proxy...`);
    // Get proxy owner account
    const [account] = await hardhat_1.ethers.getSigners();
    if (account.provider === undefined) {
        throw Error("missing provider");
    }
    // Get proxy address
    if (hardhat_1.proxy === undefined || hardhat_1.proxy === "") {
        throw Error(`missing proxies entry for '${hardhat_1.network.name}'`);
    }
    console.log(`Using proxy address '${hardhat_1.proxy}'`);
    // Check current implementation
    const impl = await hardhat_1.upgrades.erc1967.getImplementationAddress(hardhat_1.proxy);
    console.log("Current implementation address:", impl);
    // Upgrade proxy
    const Factory = await hardhat_1.ethers.getContractFactory("TablelandTables");
    const tables = await (await hardhat_1.upgrades.upgradeProxy(hardhat_1.proxy, Factory, {
        kind: "uups",
        timeout: pollTimeout,
        pollingInterval: pollInterval,
    })).deployed();
    (0, assert_1.default)(tables.address === hardhat_1.proxy, "proxy address changed");
    // Check new implementation
    // Note: We poll here because the new impl won't be visible from the proxy until the next tipset on Filecoin.
    // Note: See https://docs.filecoin.io/smart-contracts/developing-contracts/best-practices/#consistently-generating-transaction-receipts.
    const startTime = Date.now();
    while (!(await checkNewImpl(tables.address, impl))) {
        const elapsedTime = Date.now() - startTime;
        if (elapsedTime >= pollTimeout) {
            console.warn("\nProxy implementation did not change. Is this expected?");
            return;
        }
        console.log("Waiting for new implementation to be visible from proxy...");
        await sleep(pollInterval);
    }
}
async function checkNewImpl(proxy, oldImpl) {
    try {
        const impl = await hardhat_1.upgrades.erc1967.getImplementationAddress(proxy);
        if (impl !== oldImpl) {
            console.log("New implementation address:", impl);
            return true;
        }
        return false;
    }
    catch (error) {
        console.warn("Current implementation is not visible from proxy.");
        return false;
    }
}
main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});
//# sourceMappingURL=upgrade.js.map